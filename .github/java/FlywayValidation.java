import java.io.IOException;
import java.io.SequenceInputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.logging.Logger;
import java.util.stream.Stream;

/**
 * This class is used to validate new migrates in pull requests. The app expects 2 parameters:
 * 1. Version of the app, this is fetched from app's root pom.xml file
 * 2. Diff file that contains all new migrates, diff file is generated by GitHub Actions (diff of base branch and PR merge branch)
 *
 * @author miroslav.silhavy
 */
@SuppressWarnings({"NullabilityAnnotations", "UseOfSystemOutOrSystemErr"})
class FlywayValidation {

    private static final Logger LOG = Logger.getLogger(FlywayValidation.class.getName());

    private static final String MIGRATE_PATH = "main-modules/app/src/main/java/db";

    private List<String> findExistingMigrates(String searchedVersion) throws IOException {
        List<String> allMigrates = new ArrayList<>();
        Path root = Paths.get(MIGRATE_PATH);

        if (!Files.exists(root)) {
            return allMigrates;
        }

        try (Stream<Path> walk = Files.walk(root)) {
            walk.filter(p -> p.toFile().isFile())
                    .filter(p -> p.toString().contains(searchedVersion))
                    .forEach(p -> allMigrates.add(p.toFile().getName()));
        }

        LOG.info("Found " + allMigrates.size() + " migrates for version " + searchedVersion);

        return allMigrates;
    }

    private List<String> processNewMigrates(String diffFileWithNewMigrates) throws IOException {
        List<String> newMigrates;

        try (Stream<String> lines = Files.lines(Path.of(diffFileWithNewMigrates))) {
            newMigrates = lines.filter(line -> !line.trim().isEmpty())
                    .toList();
        }

        LOG.info("Listing all new migrates:");
        newMigrates.forEach(LOG::info);
        LOG.info("\n");

        return newMigrates;
    }

    private List<String> validateAddedMigrates(List<String> addedMigrates, String expectedVersion) throws Exception {
        LOG.info("Validating new migrates");

        List<String> addedMigratesFilenames = new ArrayList<>();

        for (String migrate : addedMigrates) {
            if (migrate.startsWith(MIGRATE_PATH)) {
                migrate = migrate.substring(MIGRATE_PATH.length()).replaceAll("^[\\\\/]+", "");
            }

            Path migratePath = Paths.get(migrate);
            String migrateDirectoryVersion = migratePath.getName(0).toString();
            String migrateFilename = migratePath.getFileName().toString();

            LOG.info("Validating migrate: " + migrateFilename);

            int splitIndex = migrateFilename.indexOf("__");
            if (splitIndex == -1) {
                throw new Exception("Added migrate is missing \"__\" in name: " + migrateFilename);
            }
            String migrateFilenameVersion = migrateFilename.substring(0, splitIndex);
            int migrateFilenameVersionMinorIndex = migrateFilenameVersion.lastIndexOf("_");
            String migrateFilenameVersionMinor = migrateFilenameVersion.substring(migrateFilenameVersionMinorIndex + 1);
            String migrateFilenameVersionMajor = migrateFilenameVersion.substring(0, migrateFilenameVersionMinorIndex);

            LOG.info("Migrate major version: " + migrateFilenameVersionMajor);
            LOG.info("Migrate minor version: " + migrateFilenameVersionMinor);
            LOG.info("Migrate directory version: " + migrateDirectoryVersion);

            if (!migrateDirectoryVersion.equalsIgnoreCase(expectedVersion)) {
                throw new Exception("New migrate is in invalid version directory: " + migrateDirectoryVersion + ", expected: " + expectedVersion);
            }

            if (!migrateFilenameVersionMajor.equalsIgnoreCase(expectedVersion)) {
                throw new Exception("New migrate has invalid filename version: " + migrateFilenameVersionMajor + ", expected: " + expectedVersion);
            }

            addedMigratesFilenames.add(migrateFilename);
        }

        LOG.info("All new migrates have valid directory and major version\n");

        return addedMigratesFilenames;
    }

    private void validateExistingMigrates(List<String> addedMigratesFilenames, String expectedVersion) throws Exception {
        LOG.info("Validating all current version migrates");

        List<String> existingMigrates = findExistingMigrates(expectedVersion);

        List<String> minorVersions = new ArrayList<>();
        List<String> minorVersionsExcludingAdded = new ArrayList<>();
        List<String> minorVersionsAdded = new ArrayList<>();

        for (String migrateFilename : existingMigrates) {
            LOG.info("Validating migrate: " + migrateFilename);
            int splitIndex = migrateFilename.indexOf("__");
            if (splitIndex == -1) {
                throw new Exception("Existing migrate is missing \"__\" in name: " + migrateFilename);
            }
            String migrateFilenameVersion = migrateFilename.substring(0, splitIndex);
            int migrateFilenameVersionMinorIndex = migrateFilenameVersion.lastIndexOf("_");
            String migrateFilenameVersionMinor = migrateFilenameVersion.substring(migrateFilenameVersionMinorIndex + 1);
            String migrateFilenameVersionMajor = migrateFilenameVersion.substring(0, migrateFilenameVersionMinorIndex);

            if (!migrateFilenameVersionMajor.equalsIgnoreCase(expectedVersion)) {
                throw new Exception("Existing migrate has invalid version: " + migrateFilenameVersionMajor + " expected: " + expectedVersion);
            }

            minorVersions.add(migrateFilenameVersionMinor);
            if (addedMigratesFilenames.contains(migrateFilename)) {
                minorVersionsAdded.add(migrateFilenameVersionMinor);
            } else {
                minorVersionsExcludingAdded.add(migrateFilenameVersionMinor);
            }
        }

        Set<String> duplicates = findDuplicatesInMinorVersions(minorVersions);

        LOG.info("Checking for duplicate minor versions");

        if (!duplicates.isEmpty()) {
            StringBuilder message = new StringBuilder("Duplicate minor versions found:\n");
            for (String duplicate : duplicates) {
                message.append(duplicate).append("\n");
            }
            throw new Exception(message.toString());
        } else {
            LOG.info("No duplicate minor versions found\n");
        }

        LOG.info("Checking for out-of-order minor versions");

        for (String addedMinor : minorVersionsAdded) {
            int addNumMinor = Integer.parseInt(addedMinor);
            for (String existingMinor : minorVersionsExcludingAdded) {
                int existingNumMinor = Integer.parseInt(existingMinor);
                if (addNumMinor < existingNumMinor) {
                    throw new Exception("New migrate has invalid minor version: " + addedMinor + ", expected greater than: " + existingMinor);
                }
            }
        }

        LOG.info("No out-of-order minor versions found");
    }

    private Set<String> findDuplicatesInMinorVersions(List<String> minorVersions) {
        Set<String> duplicates = new HashSet<>();
        for (String minorVersion : minorVersions) {
            if (Collections.frequency(minorVersions, minorVersion) > 1) {
                duplicates.add(minorVersion);
            }
        }
        return duplicates;
    }

    private void validate(String inputMigrateFile, String replacedInputVersion) throws Exception {
        List<String> addedMigrates = processNewMigrates(inputMigrateFile);
        List<String> addedMigratesFilenames = validateAddedMigrates(addedMigrates, replacedInputVersion);
        validateExistingMigrates(addedMigratesFilenames, replacedInputVersion);
    }

    public static void main(String[] args) throws IOException, InterruptedException {
        if (args.length < 2) {
            LOG.severe("Error: Missing required input parameters. Usage: java FlywayValidation.java <app_version> <file_with_new_migrates>");
            System.exit(1);
        }
        String input_version = args[0];
        String input_migrate_file = args[1];
        String replaced_input_version = "v" + input_version.replaceAll("\\D+", "_");

        LOG.info("Provided application version " + replaced_input_version + "\n");

        boolean isWindows = System.getProperty("os.name")
                .toLowerCase().startsWith("windows");
        String result = "";

        LOG.info("\n");
        LOG.info("Flyway validation results:");

        boolean success = true;
        try {
            new FlywayValidation().validate(input_migrate_file, replaced_input_version);
            result = "Flyway validation successful";
            LOG.info(result);
        } catch (Exception e) {
            success = false;
            result = e.getMessage();
            LOG.severe(result);
        } finally {
            if (!isWindows) {
                LOG.info("\nSetting Github Action property $GITHUB_STEP_SUMMARY");
                setGithubActionProperty(result);
            }
            if (!success) {
                System.exit(1);
            }
        }
    }

    private static void setGithubActionProperty(String result) throws IOException, InterruptedException {
        Process process = new ProcessBuilder("sh", "-c", "echo \"Flyway validation results:\" >> $GITHUB_STEP_SUMMARY").start();
        new ProcessBuilder("sh", "-c", "echo \"" + result + "\" >> $GITHUB_STEP_SUMMARY").start();
        new ProcessBuilder("sh", "-c", "echo \"message=" + result + "\" >> $GITHUB_OUTPUT").start();
        int exitCode = process.waitFor();
        if (exitCode != 0) {
            LOG.severe("Exited with error code " + exitCode);
            Scanner scanner = new Scanner(process.getErrorStream());
            while (scanner.hasNextLine()) {
                LOG.severe(scanner.nextLine());
            }
        }
    }

}